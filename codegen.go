package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"io"
	"strconv"
	"strings"
	"text/template"

	"go.e43.eu/go-onc/oncrpcgen/ast"
)

func DocComment(a ast.Attributes, def string) string {
	doc := a.GetStringDefault("doc", def)
	if doc == "" {
		return ""
	}

	lines := strings.Split(doc, "\n")
	return "// " + strings.Join(lines, "\n //")
}

func GoTypeName(s *ast.Specification, t *ast.Type) (string, string, error) {
	switch t.Kind {
	case ast.TYPE_BOOL:
		return "", "bool", nil
	case ast.TYPE_INT:
		return "", "int32", nil
	case ast.TYPE_UNSIGNED_INT:
		return "", "uint32", nil
	case ast.TYPE_HYPER:
		return "", "int64", nil
	case ast.TYPE_UNSIGNED_HYPER:
		return "", "uint64", nil
	case ast.TYPE_FLOAT:
		return "", "float32", nil
	case ast.TYPE_DOUBLE:
		return "", "float64", nil
	case ast.TYPE_STRING:
		return "", "string", nil
	case ast.TYPE_REF:
		defn, resolved, err := t.FollowRef(s)
		if err != nil {
			return "", "", err
		}
		pfx := ""
		switch resolved.Kind {
		case ast.TYPE_STRUCT, ast.TYPE_UNION:
			pfx = "*"
		}
		return pfx, CamelCase(defn.Name), nil
	default:
		return "", "", fmt.Errorf("Don't know how to name a %s", t.Kind)
	}
}

func GoValue(v *ast.Constant) string {
	switch v.Type {
	case ast.CONST_BOOL:
		return fmt.Sprintf("%v", v.VBool)
	case ast.CONST_POS_INT:
		// Heuristic
		if v.VPosInt <= 0xFFFF {
			return fmt.Sprintf("%d", v.VPosInt)
		} else {
			return fmt.Sprintf("0x%X", v.VPosInt)
		}
	case ast.CONST_NEG_INT:
		return fmt.Sprintf("-%d", v.VNegInt)
	case ast.CONST_FLOAT:
		return fmt.Sprintf("%f", v.VFloat)
	case ast.CONST_STRING:
		return strconv.Quote(v.VString)
	case ast.CONST_ENUM:
		return fmt.Sprintf("%d", v.VEnum)
	default:
		panic(fmt.Sprintf("Don't know how to valueize a %s", v.Type))
	}
}

var templateFuncs = map[string]interface{}{
	"GoName":      CamelCase,
	"GoValue":     GoValue,
	"Declaration": GenDeclaration,
}

func compileTemplate(name, s string) *template.Template {
	return template.Must(template.New(name).Funcs(templateFuncs).Parse(s[1:]))
}

var specTemplate = compileTemplate("specification", `
// AUTOGENERATED CODE - Do not modify by hand
// Generated by onrpcgen

{{.Doc}}
package {{.PackageName}}

import (
	"encoding"
	"errors"
	"fmt"
	"strconv"
)

`)

var footerTemplate = compileTemplate("footer", `

// Dummy type assertions - added to ensure that no errors are generated
// because we didn't use one of our imports  
var (
	_ encoding.TextMarshaler = nil
	_ = errors.New
	_ fmt.Stringer = nil
	_ = strconv.ErrSyntax
)
`)

func GenSpecification(s *ast.Specification) ([]byte, error) {
	buf := new(bytes.Buffer)
	if err := genSpecification(buf, s); err != nil {
		return nil, err
	}

	return format.Source(buf.Bytes())
}

func genSpecification(w io.Writer, s *ast.Specification) error {
	packageName := s.Attributes.GetStringDefault("go_package", "x")

	if err := specTemplate.Execute(w, map[string]interface{}{
		"Doc":         DocComment(s.Attributes, fmt.Sprintf("%s is an autogenerated XDR package", packageName)),
		"PackageName": packageName,
	}); err != nil {
		return err
	}

	for _, d := range s.Definitions {
		// Skip enums - we will generate their definitions while generating the enum itself
		if d.Body.Kind == ast.DEFINITION_KIND_CONSTANT && d.Body.Constant.Type == ast.CONST_ENUM {
			continue
		}

		if err := GenDefinition(w, s, d); err != nil {
			return err
		}
		fmt.Fprintln(w)
	}

	return footerTemplate.Execute(w, nil)
}

func GenDefinition(w io.Writer, s *ast.Specification, d *ast.Definition) (err error) {
	defer func() {
		if err != nil {
			err = fmt.Errorf("Rendering '%s': %v", d.Name, err)
		}
	}()
	switch d.Body.Kind {
	case ast.DEFINITION_KIND_TYPE:
		return GenTypeDefinition(w, s, d.Name, d.Body.Type, d.Attributes)

	case ast.DEFINITION_KIND_CONSTANT:
		return GenValueDefinition(w, d.Name, d.Body.Constant, d.Attributes)

	default:
		return errors.New("Unknown definition kind")
	}
}

func GenTypeDefinition(w io.Writer, s *ast.Specification, name string, t *ast.Type, a ast.Attributes) error {
	switch t.Kind {
	case ast.TYPE_ENUM:
		return GenEnumDefinition(w, name, t.EnumSpec, a)

	case ast.TYPE_STRUCT:
		return GenStructDefinition(w, s, name, t.StructSpec, a)

	case ast.TYPE_UNION:
		return GenUnionDefinition(w, s, name, t.UnionSpec, a)

	case ast.TYPE_TYPEDEF:
		return GenTypedefDefinition(w, s, name, t.TypeDef, a)

	default:
		_, err := fmt.Fprintln(w, "// Warning: Don't know how to generate ", t.Kind, name)
		return err
	}
}

func GenTypedefDefinition(w io.Writer, s *ast.Specification, name string, t *ast.Declaration, a ast.Attributes) error {
	decl, err := GenDeclaration(s, t, declModeTypedef)
	if err != nil {
		return err
	}

	comment := DocComment(a, "")
	if comment != "" {
		_, err := fmt.Fprintln(w, comment)
		if err != nil {
			return err
		}
	}

	_, err = fmt.Fprintf(w, "type %s\n", decl)
	return err
}

var enumTemplate = compileTemplate("enum", `
{{$TypeName := .TypeName}}
{{$GoType := GoName $TypeName}}
{{.Doc}}
type {{$GoType}} uint32
const (
{{- range .Options}}
	{{GoName .Name}} {{GoName $TypeName}} = {{.Value}}
{{- end}}
)

var x{{$GoType}}ValToStr = map[{{$GoType}}]string{
{{- range $Value, $Name := .Values}}
	{{GoName $Name}}: "{{$Name}}", // {{$Value}}
{{- end}}
}

var x{{$GoType}}StrToVal = map[string]{{$GoType}}{
{{- range .Options}}
	"{{.Name}}": {{GoName .Name}},
{{- end}}
}

func (v {{$GoType}}) String() string {
	if s, ok := x{{$GoType}}ValToStr[v]; ok {
		return s
	}
	return strconv.Itoa(int(v))
}

func (v {{$GoType}}) MarshalText() ([]byte, error) {
	if s, ok := x{{$GoType}}ValToStr[v]; ok {
		return []byte(s), nil
	}
	return nil, errors.New("Invalid enum value")
}

func (v *{{$GoType}}) UnmarshalText(buf []byte) (error) {
	if nv, ok := x{{$GoType}}StrToVal[string(buf)]; ok {
		*v = nv
		return nil
	}
	return errors.New("Invalid enum value")
}

func (_ {{$GoType}}) ValidEnum(v int32) bool {
	_, ok := x{{$GoType}}ValToStr[{{$GoType}}(v)]
	return ok
}

var (
	_ fmt.Stringer = {{$GoType}}(0)
	_ encoding.TextMarshaler = {{$GoType}}(0)
	_ encoding.TextUnmarshaler = new({{$GoType}})
)
`)

func GenEnumDefinition(w io.Writer, name string, es *ast.EnumSpec, a ast.Attributes) error {
	values := make(map[uint32]string)
	for _, m := range es.Options {
		if _, exists := values[m.Value]; !exists {
			values[m.Value] = m.Name
		}
	}

	return enumTemplate.Execute(w, map[string]interface{}{
		"Doc":      DocComment(a, fmt.Sprintf("%s is enum %s", CamelCase(name), name)),
		"TypeName": name,
		"Options":  es.Options,
		"Values":   values,
	})
}

const (
	declModeDefault     = "default"
	declModeUnionOption = "union"
	declModeTypedef     = "typedef"
)

func checkMapLikeDef(s *ast.Specification, d *ast.Declaration) error {
	t, err := d.Type.Resolve(s)
	if err != nil {
		return err
	}
	if t.Kind != ast.TYPE_STRUCT {
		return fmt.Errorf("Can't generate %s as map because type must be a struct, is %s", d.Name, t.Kind)
	}

	if len(t.StructSpec.Members) != 2 {
		return fmt.Errorf("Can't generate %s as map becasue struct has %d members, must be 2", d.Name, len(t.StructSpec.Members))
	}

	if d.Modifier.Kind != ast.DECLARATION_MODIFIER_FLEXIBLE && d.Modifier.Kind != ast.DECLARATION_MODIFIER_UNBOUNDED {
		return fmt.Errorf("Can't generate %s as map because modifier type %s unsupported", d.Name, d.Modifier.Kind)
	}
	return nil
}

func GenDeclaration(spec *ast.Specification, d *ast.Declaration, mode string) (string, error) {
	var (
		s    string
		tags []string
	)

	if d.Attributes.GetString("mode") == "map" {
		if err := checkMapLikeDef(spec, d); err != nil {
			return "", err
		}

		t, err := d.Type.Resolve(spec)
		if err != nil {
			return "", err
		}

		keyPfx, keyType, err := GoTypeName(spec, t.StructSpec.Members[0].Type)
		if err != nil {
			return "", err
		}

		if keyPfx != "" {
			return "", fmt.Errorf("Can't use %s as map key", keyType)
		}

		valPfx, valType, err := GoTypeName(spec, t.StructSpec.Members[1].Type)
		if err != nil {
			return "", err
		}

		s = fmt.Sprintf("%s map[%s]%s%s", CamelCase(d.Name), keyType, valPfx, valType)
	} else if d.Type.Kind == ast.TYPE_STRING {
		s = fmt.Sprintf("%s string", CamelCase(d.Name))
		switch d.Modifier.Kind {
		case ast.DECLARATION_MODIFIER_NONE, ast.DECLARATION_MODIFIER_OPTIONAL:
			return "", fmt.Errorf("Non-array string")
		case ast.DECLARATION_MODIFIER_FIXED:
			tags = append(tags, fmt.Sprintf("len:%d", d.Modifier.Size))
		case ast.DECLARATION_MODIFIER_FLEXIBLE:
			tags = append(tags, fmt.Sprintf("maxlen:%d", d.Modifier.Size))
		}
	} else if d.Type.Kind == ast.TYPE_OPAQUE {
		switch d.Modifier.Kind {
		case ast.DECLARATION_MODIFIER_NONE, ast.DECLARATION_MODIFIER_OPTIONAL:
			return "", fmt.Errorf("Non-array opaque")
		case ast.DECLARATION_MODIFIER_FIXED:
			s = fmt.Sprintf("%s [%d]byte", CamelCase(d.Name), d.Modifier.Size)
		case ast.DECLARATION_MODIFIER_FLEXIBLE:
			s = fmt.Sprintf("%s []byte", CamelCase(d.Name))
			tags = append(tags, fmt.Sprintf("maxlen:%d", d.Modifier.Size))
		case ast.DECLARATION_MODIFIER_UNBOUNDED:
			s = fmt.Sprintf("%s []byte", CamelCase(d.Name))
		}
	} else {
		pfx, typeName, err := GoTypeName(spec, d.Type)
		if err != nil {
			return "", err
		}
		switch d.Modifier.Kind {
		case ast.DECLARATION_MODIFIER_NONE:
			// Nothing
		case ast.DECLARATION_MODIFIER_OPTIONAL:
			// pfx might already be *. That's OK
			tags = append(tags, "opt")
			pfx = "*"
		case ast.DECLARATION_MODIFIER_FIXED:
			pfx = fmt.Sprintf("[%d]%s", d.Modifier.Size, pfx)
		case ast.DECLARATION_MODIFIER_FLEXIBLE:
			pfx = "[]" + pfx
		case ast.DECLARATION_MODIFIER_UNBOUNDED:
			pfx = "[]" + pfx
		}
		s = fmt.Sprintf("%s %s%s", CamelCase(d.Name), pfx, typeName)
	}

	if mode != declModeTypedef {
		omitEmpty := ""
		if mode == declModeUnionOption || d.Modifier.Kind == ast.DECLARATION_MODIFIER_OPTIONAL {
			omitEmpty = ",omitempty"
		}
		xdrt := ""
		if len(tags) > 0 {
			xdrt = fmt.Sprintf("xdr:\"%s\" ", strings.Join(tags, ","))
		}
		s = fmt.Sprintf("%s `%sjson:\"%s%s\"`", s, xdrt, d.Name, omitEmpty)
	}

	comment := DocComment(d.Attributes, "")
	if comment != "" {
		s = fmt.Sprintf("%s\n%s", comment, s)
	}

	return s, nil
}

func NameIfAnonymous(w io.Writer, s *ast.Specification, parentName string, d *ast.Declaration) error {
	switch d.Type.Kind {
	case ast.TYPE_ENUM,
		ast.TYPE_STRUCT,
		ast.TYPE_UNION:
		// Continue
	default:
		return nil
	}

	name := fmt.Sprintf("%s.%s", parentName, d.Name)
	nType := *d.Type
	dIdx, err := s.PutDefinition(&ast.Definition{
		Name: name,
		Body: &ast.Definition_Body{
			Kind: ast.DEFINITION_KIND_TYPE,
			Type: &nType,
		},
		Attributes: d.Attributes,
	})
	if err != nil {
		return err
	}

	if err := GenTypeDefinition(w, s, name, d.Type, d.Attributes); err != nil {
		return err
	}

	*d.Type = ast.Type{
		Kind: ast.TYPE_REF,
		Ref:  dIdx,
	}
	return nil
}

var structTemplate = compileTemplate("struct", `
{{- $Spec := .Specification}}
{{- $TypeName := .TypeName}}
{{- $GoType := GoName $TypeName}}
{{.Doc}}
type {{$GoType}} struct {
{{- range .Members}}
	{{Declaration $Spec . "default"}}
{{- end}}
}
`)

func GenStructDefinition(w io.Writer, s *ast.Specification, name string, ss *ast.StructSpec, a ast.Attributes) error {
	for i := range ss.Members {
		if err := NameIfAnonymous(w, s, name, ss.Members[i]); err != nil {
			return err
		}
	}

	return structTemplate.Execute(w, map[string]interface{}{
		"Doc":           DocComment(a, fmt.Sprintf("%s is struct %s", CamelCase(name), name)),
		"TypeName":      name,
		"Members":       ss.Members,
		"Specification": s,
	})
}

var unionTemplate = compileTemplate("union", `
{{- $Spec := .Specification}}
{{- $TypeName := .TypeName}}
{{- $GoType := GoName $TypeName}}
{{.Doc}}
type {{$GoType}} struct {
	{{Declaration $Spec .Discriminant "default"}}
{{- range .Members}}
	{{- if not .IsVoid}}
		{{Declaration $Spec . "union"}}
	{{- end}}
{{- end}}
}

func (u *{{$GoType}}) UnionDiscriminant() interface{} {
	return u.{{GoName .Discriminant.Name}}
}

func (u *{{$GoType}}) UnionValue() (interface{}, error) {
	switch u.{{GoName .Discriminant.Name}} {
	{{- range $Val, $Field := .NameToField}}
	case {{$Val}}:
		{{- if $Field}}
			return u.{{GoName $Field}}, nil
		{{- else}}
			return nil, nil
		{{- end}}
	{{- end}}
	default:
	{{- if .Default}}
		{{- if not .Default.Name}}
			return nil, nil 
		{{- else }}
			return u.{{GoName .Default.Name}}, nil
		{{- end}}
	{{- else}}
		return nil, errors.New("Invalid discriminant")
	{{- end}}
	}
}

func (u *{{$GoType}}) SwitchFieldName() string {
	return "{{GoName .Discriminant.Name}}"
}

func (u *{{$GoType}}) ArmForSwitch(sw uint32) (string, bool) {
	switch sw {
	{{- range $RawVal, $Alt := .Alternatives}}
	case uint32({{GoValue $Alt.Value}}):
		{{- if $Alt.Declaration.IsVoid}}
			return "", true
		{{- else}}
			return "{{GoName $Alt.Declaration.Name}}", true
		{{- end}}
	{{- end}}
	default:
	{{- if .Default}}
		{{- if .Default.IsVoid}}
			return "", true 
		{{- else }}
			return "{{GoName .Default.Name}}", true
		{{- end}}
	{{- else}}
		return "", false
	{{- end}}
	}
}
`)

func GenUnionDefinition(w io.Writer, s *ast.Specification, name string, us *ast.UnionSpec, a ast.Attributes) error {
	if err := NameIfAnonymous(w, s, name, us.Discriminant); err != nil {
		return err
	}

	for i := range us.Members {
		if err := NameIfAnonymous(w, s, name, us.Members[i]); err != nil {
			return err
		}
	}

	discrimType, err := us.Discriminant.Type.Resolve(s)
	if err != nil {
		return err
	}

	var discrimEnum *ast.EnumSpec
	if discrimType.Kind == ast.TYPE_ENUM {
		discrimEnum = discrimType.EnumSpec
	}

	optNameToField := make(map[string]string)
	for value, membPos := range us.Options {
		var name string
		if discrimEnum != nil {
			name = CamelCase(discrimEnum.GetName(value))
		}
		if name == "" {
			name = strconv.FormatUint(uint64(value), 10)
		}
		optNameToField[name] = us.Members[membPos].Name
	}

	return unionTemplate.Execute(w, map[string]interface{}{
		"Doc":           DocComment(a, fmt.Sprintf("%s is union %s", CamelCase(name), name)),
		"TypeName":      name,
		"Discriminant":  us.Discriminant,
		"Members":       us.Members,
		"NameToField":   optNameToField,
		"Specification": s,
	})
}

func GenValueDefinition(w io.Writer, name string, v *ast.Constant, a ast.Attributes) error {
	comment := DocComment(a, "")
	if comment != "" {
		_, err := fmt.Fprintln(w, comment)
		if err != nil {
			return err
		}
	}
	_, err := fmt.Fprintf(w, "const %s = %s\n", CamelCase(name), GoValue(v))
	return err
}
