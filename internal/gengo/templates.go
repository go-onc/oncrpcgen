package gengo

import "text/template"

var templateFuncs = map[string]interface{}{
	"GoName":                 CamelCase,
	"GoValue":                GoValue,
	"Declaration":            GenBasicDeclaration,
	"UnionSwitchDeclaration": GenUnionSwitchDeclaration,
	"UnionDeclaration":       GenUnionDeclaration,
}

func compileTemplate(name, s string) *template.Template {
	return template.Must(template.New(name).Funcs(templateFuncs).Parse(s[1:]))
}

// File header template
var headerTemplate = compileTemplate("header", `
// Code generated by xdrgen-go - DO NOT EDIT.

{{.Doc}}
package {{.PackageName}}

import (
	"encoding"
	"errors"
	"fmt"
	"strconv"

	xdr "go.e43.eu/xdr/interfaces"
)

`)

// File footer template
var footerTemplate = compileTemplate("footer", `
// Dummy type assertions - added to ensure that no errors are generated
// because we didn't use one of our imports  
var (
	_ encoding.TextMarshaler = nil
	_ fmt.Stringer = nil
	_ xdr.Marshaler = nil 
	_ = strconv.ErrSyntax
	_ = errors.New
)
`)

// Template for generating an xdr.Marshaler "proxy" implementation for typedefs
var typedefProxyTemplate = compileTemplate("typedefProxy", `
{{- $GoType := GoName .TypeName}}
type x{{$GoType}} struct {
	{{Declaration .Specification .Decl}}
}

// MarshalXDR satisfies xdr.Marshaler
func (v {{$GoType}}) MarshalXDR(e xdr.Encoder) error {
	return e.Encode(x{{$GoType}}{v})
}

// UnmarshalXDR satisfies xdr.Marshaler
func (v *{{$GoType}}) UnmarshalXDR(d xdr.Decoder) error
	xv := x{{$GoType}}{}
	err := d.Decode(&xv)
	*v = xv.{{GoName .Decl.Name}}
	return err
}

var _ xdr.Marshaler = new({{$GoType}})
`)

// Used to generate enum declarations
var enumTemplate = compileTemplate("enum", `
{{- $TypeName := .TypeName}}
{{- $GoType := GoName $TypeName}}
{{.Doc}}
type {{$GoType}} uint32
const (
{{- range .Options}}
	{{GoName .Name}} {{GoName $TypeName}} = {{.Value}}
{{- end}}
)

var x{{$GoType}}ValToStr = map[{{$GoType}}]string{
{{- range $Value, $Name := .Values}}
	{{GoName $Name}}: "{{$Name}}", // {{$Value}}
{{- end}}
}

var x{{$GoType}}StrToVal = map[string]{{$GoType}}{
{{- range .Options}}
	"{{.Name}}": {{GoName .Name}},
{{- end}}
}

// String satisfies fmt.Stringer
func (v {{$GoType}}) String() string {
	if s, ok := x{{$GoType}}ValToStr[v]; ok {
		return s
	}
	return strconv.Itoa(int(v))
}

// MarshalText satisfies encoding.TextMarshaler
func (v {{$GoType}}) MarshalText() ([]byte, error) {
	if s, ok := x{{$GoType}}ValToStr[v]; ok {
		return []byte(s), nil
	}
	return nil, errors.New("Invalid enum value")
}

// UnmarshalText satisfies encoding.TextUnmarshaler
func (v *{{$GoType}}) UnmarshalText(buf []byte) (error) {
	if nv, ok := x{{$GoType}}StrToVal[string(buf)]; ok {
		*v = nv
		return nil
	}
	return errors.New("Invalid enum value")
}

func (v {{$GoType}}) IsKnown() bool {
	_, ok := x{{$GoType}}ValToStr[v]
	return ok
}

var (
	_ fmt.Stringer = {{$GoType}}(0)
	_ encoding.TextMarshaler = {{$GoType}}(0)
	_ encoding.TextUnmarshaler = new({{$GoType}})
)
`)

// Used to generate unions
var unionTemplate = compileTemplate("union", `
{{- $Spec := .Specification}}
{{- $TypeName := .TypeName}}
{{- $GoType := GoName $TypeName}}
{{.Doc}}
type {{$GoType}} struct {
	{{UnionSwitchDeclaration $Spec .Discriminant}}
{{- range .AnnotatedMembers}}
	{{UnionDeclaration $Spec .}}
{{- end}}
}

func (u *{{$GoType}}) UnionDiscriminant() interface{} {
	return u.{{GoName .Discriminant.Name}}
}

func (u *{{$GoType}}) UnionValue() (interface{}, error) {
	switch u.{{GoName .Discriminant.Name}} {
	{{- range $Val, $Field := .NameToField}}
	case {{$Val}}:
		{{- if $Field}}
			return u.{{GoName $Field}}, nil
		{{- else}}
			return nil, nil
		{{- end}}
	{{- end}}
	default:
	{{- if .Default}}
		{{- if not .Default.Name}}
			return nil, nil 
		{{- else }}
			return u.{{GoName .Default.Name}}, nil
		{{- end}}
	{{- else}}
		return nil, errors.New("Invalid discriminant")
	{{- end}}
	}
}
`)
